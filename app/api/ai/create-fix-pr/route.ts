import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/utils/supabase/server'
import { GitHubClient } from '@/lib/github/client'
import { ClaudeClient } from '@/lib/ai/claude-client'

export async function POST(request: NextRequest) {
  try {
    const { analysisId, autoApply = false } = await request.json()

    if (!analysisId) {
      return NextResponse.json({ error: 'Missing analysis ID' }, { status: 400 })
    }

    const supabase = await createClient()
    
    // Get analysis details
    const { data: analysis, error: analysisError } = await supabase
      .from('ai_analyses')
      .select('*, support_tickets(*)')
      .eq('id', analysisId)
      .single()

    if (analysisError || !analysis) {
      return NextResponse.json({ error: 'Analysis not found' }, { status: 404 })
    }

    // Get GitHub connection
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { data: githubConnection } = await supabase
      .from('github_connections')
      .select('access_token')
      .eq('user_id', user.id)
      .single()

    if (!githubConnection?.access_token) {
      return NextResponse.json({ error: 'GitHub not connected' }, { status: 400 })
    }

    // Initialize clients
    const github = new GitHubClient(githubConnection.access_token)
    const claude = new ClaudeClient()

    // Parse repository
    const [owner, repo] = analysis.repository.split('/')

    // Generate fix based on analysis
    const suggestedFix = analysis.analysis_data.suggestedFix
    
    if (!suggestedFix?.codeChanges || suggestedFix.codeChanges.length === 0) {
      return NextResponse.json({ error: 'No code changes available in analysis' }, { status: 400 })
    }

    // Create a new branch for the fix
    const branchName = `ai-fix/${analysis.ticket_id.slice(0, 8)}-${Date.now()}`
    await github.createBranch(owner, repo, branchName)

    // Apply each code change
    const appliedChanges = []
    for (const change of suggestedFix.codeChanges) {
      try {
        // Get current file content
        const currentFile = await github.getFileContent(owner, repo, change.file, branchName)
        
        if (!currentFile) {
          console.warn(`File not found: ${change.file}`)
          continue
        }

        // Generate the complete fixed file
        const fixResponse = await claude.generateFix(
          analysis.analysis_data,
          currentFile.content,
          {
            fileName: change.file,
            language: change.file.endsWith('.tsx') ? 'typescript' : 'javascript',
            projectContext: `Fixing: ${analysis.support_tickets.title}`
          }
        )

        if (fixResponse?.fixedCode) {
          // Update the file
          await github.updateFile(
            owner,
            repo,
            change.file,
            fixResponse.fixedCode,
            `Fix: ${change.explanation || 'Apply AI-suggested fix'}`,
            branchName,
            currentFile.sha
          )

          appliedChanges.push({
            file: change.file,
            status: 'applied',
            changes: fixResponse.changes
          })
        }
      } catch (error) {
        console.error(`Failed to apply change to ${change.file}:`, error)
        appliedChanges.push({
          file: change.file,
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error'
        })
      }
    }

    // Create pull request
    const prTitle = `ðŸ¤– AI Fix: ${analysis.support_tickets.title}`
    const prBody = `## ðŸ¤– AI-Generated Fix

### Issue
**Ticket ID:** ${analysis.ticket_id}
**Title:** ${analysis.support_tickets.title}
**Description:** ${analysis.support_tickets.description}

### Analysis
- **Root Cause:** ${analysis.analysis_data.rootCause}
- **Complexity:** ${analysis.analysis_data.complexity}/10
- **Confidence:** ${analysis.analysis_data.confidence}%
- **Auto-Fixable:** ${analysis.analysis_data.isAutoFixable ? 'Yes' : 'No'}

### Changes Applied
${appliedChanges.map(c => `- ${c.status === 'applied' ? 'âœ…' : 'âŒ'} ${c.file}`).join('\n')}

### Suggested Fix
${analysis.analysis_data.suggestedFix.description}

### Risks
${analysis.analysis_data.risks?.map((r: string) => `- âš ï¸ ${r}`).join('\n') || 'No significant risks identified'}

### Testing Required
${analysis.analysis_data.testingRequired?.map((t: string) => `- [ ] ${t}`).join('\n') || '- [ ] Standard testing procedures'}

---
*This PR was automatically generated by the AI Support System using Claude 3.5 Sonnet*
*Please review carefully before merging*`

    const pr = await github.createPullRequest(
      owner,
      repo,
      prTitle,
      prBody,
      branchName
    )

    // Store PR information
    const { data: fixRecord } = await supabase
      .from('ai_fixes')
      .insert({
        analysis_id: analysisId,
        ticket_id: analysis.ticket_id,
        pr_number: pr.number,
        pr_url: pr.html_url,
        branch_name: branchName,
        files_changed: appliedChanges.map(c => c.file),
        changes_applied: appliedChanges,
        status: 'pending_review',
        created_at: new Date().toISOString()
      })
      .select()
      .single()

    // Update ticket status
    await supabase
      .from('support_tickets')
      .update({
        status: 'in_progress',
        metadata: {
          ...analysis.support_tickets.metadata,
          ai_pr_url: pr.html_url,
          ai_pr_number: pr.number
        }
      })
      .eq('id', analysis.ticket_id)

    return NextResponse.json({
      success: true,
      pr: {
        number: pr.number,
        url: pr.html_url,
        branch: branchName
      },
      fix: fixRecord,
      appliedChanges
    })

  } catch (error) {
    console.error('Fix PR creation error:', error)
    return NextResponse.json(
      { error: 'Failed to create fix PR', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
}